# Introduction
This package provides an object to support mathematical operations normally used in
the development of navigation solutions, sensor simulation, transfer alignemnt, and
similars.

In the background, the object uses numpy arrays, but improves it with methods to support
changing of reference frames, usage of quaternions, convertion among transformation 
matrices, etc.

# kArrayNav
![classes.png](classes.png?raw=true "UML generated by pyreverse")

## to create a vector:
```
kArrayNav( [1,2,3], hvector={True|False} )
```
This is the standard sintax to create a vector-object. The boolean parameter `hvector` defines whether the vector is
vertical or horizontal.

## to create a matrix:
```
kArrayNav( [[1,2,3],[4,5,6]] )
```
This is the standard sintax to create a matrix. The boolean parameter `hvector` is not used here.

## transposing:
```
a = a.T # it works for vectors!
```

## to convert a 3D vector to its respective skew-matrix:
```
a = kArrayNav( [1,2,3] ) # any hvector does the trick
b = a.to_skew()
```

## to convert to/from rad/deg:
```
angles_deg = kArrayNav( [10,20,30] )
angles_rad = angles_deg.to_rad()
```

## to calculate the cross-product among 3D-vectors:
```
a = kArrayNav( [1,2,3], hvector=False )
b = kArrayNav( [5,3,1], hvector=False )
c = a.X( b )
c = a.to_skew() * b # alternative
```

## to convert to/from euler angles from/to quaternions:
```
euler = kArrayNav( [10,20,30] ).to_rad()
q4    = euler2Q()
euler = q4.Q2euler()
```

## to convert to/from quaternions from/to transformation-matrix:
```
euler = kArrayNav( [10,20,30] ).to_rad()
q4    = euler.euler2Q()
C     = q4.Q2C()
q4    = C.C2Q()
```

## to convert from/to euler angles to/from transformation-matrix:
```
euler = kArrayNav( [10,20,30] ).to_rad()
C     = euler.euler2C()
euler = C.C2euler().to_deg()
```

## to multiply quaternions:
```
qa2b = ...                  # from 'a' to 'b'
qb2c = ...                  # from 'b' to 'c'
qa2c = qb2c.q1_x_q2(qa2b)   # from 'a' to 'c'
```

## transformation matrix from 'earth' to 'navigation' frame:
```
latitude_rad  = ...
longitude_rad = ...
Re2n = kArrayNav().Re2n(latitude_rad, longitude_rad)
```

## transformation among earth-centered-earth-fixed representations:
```
llh = kArrayNav( [lat_rad, long_rad, altitude_m] ) # latitude, longitude, altitude
xyz = llh.ecef_llh2xyz()                           # x_e, y_e, z_e [m]
llh = xyz.ecef_xyz2llh()
```

## derivative of quaternions:
```
dqdt = qi2b.dqdt( w_ib_b )
```

## inverse of a quaternion:
```
euler = kArrayNav( [10,20,30] ).to_rad()
q4    = euler.euler2Q()
q_inv = q4.Qinv()
e2    = q_inv.Q2euler().to_deg()
```

## derivative of euler angles:
```
euler = kArrayNav( [10,20,30] ).to_rad()
w     = kArrayNav( [-1,0,1] ) # [rad/s]
dEdt  = euler.dEulerDt(w)
```

## local gravity in geografic frame:
```
local_gravity_n = gravity_n ( latitude, altitude )
```

## derivative of lat/long/alt:
```
dLLHdt = dLLH_dt(...)
```

## to apply a function on the current array:
```
a = kArrayNav( [[2,0,0],[0,4,0],[0,0,10]] )
b = a.apply(lambda x: np.linalg.inv(x))
```

# How to use
```
import sys
sys.path.append(< up to where folder karraynav is >)
from karraynav import kArrayNav
```

# How to test it
```
kArrayNavTests().do_tests()
```
